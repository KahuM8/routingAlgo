
import java.util.ArrayList;
import java.util.List;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * 
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        return Math.sqrt(Math.pow(node1.getX() - node2.getX(), 2) + Math.pow(node1.getY() - node2.getY(), 2));
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent
     * nodes in the routes.
     * 
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        double sum = 0.0;
        VRPNode depot = instance.getDepot();
        for (int i = 0; i < solution.getRoutes().size(); i++) {
            List<Integer> route = solution.getRoutes().get(i);
            VRPNode current = depot;
            for (int j = 0; j < route.size(); j++) {
                VRPNode next = instance.getNodes().get(route.get(j));
                sum += calculateEuclideanDistance(current, next);
                current = next;
            }
            sum += calculateEuclideanDistance(current, depot); // return to depot
        }

        return sum;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour
     * heuristic.
     * 
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        List<VRPNode> nodes = new ArrayList<>(instance.getNodes().values());
        List<List<Integer>> routes = new ArrayList<>();
        VRPNode depo = instance.getDepot();
        while (!nodes.isEmpty()) {
            double cap = instance.getCapacity();
            ArrayList<Integer> route = new ArrayList<>();
            VRPNode current = depo;
            while (!nodes.isEmpty()) {
                VRPNode minNode = null;
                double min = Double.MAX_VALUE;
                for (int i = 0; i < nodes.size(); i++) {
                    if (nodes.get(i).getDemand() > cap) {
                        continue;
                    }
                    double distance = calculateEuclideanDistance(current, nodes.get(i));
                    if (distance < min) {
                        min = distance;
                        minNode = nodes.get(i);
                    }
                }
                if (minNode == null) {
                    break;
                }
                cap -= minNode.getDemand();

                route.add(minNode.getID());
                current = minNode;
                nodes.remove(minNode);
            }
            routes.add(route);
        }
        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * 
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        List<List<Integer>> routes = initializeRoutes(instance);
        double[][] savings = calculateSavings(instance);

        while (true) {
            double bestSaving = 0;
            List<Integer> bestMerge = null;
            for (int i = 0; i < routes.size(); i++) {
                List<Integer> route1 = routes.get(i);
                for (int j = 0; j < routes.size(); j++) {
                    if (i == j)
                        continue;

                    List<Integer> route2 = routes.get(j);
                    double saving = savings[route1.get(route1.size() - 1)][route2.get(0)];
                    if (saving <= bestSaving)
                        continue;

                    List<Integer> merge = mergeRoutes(route1, route2, instance);
                    double totalDemand = calculateTotalDemand(merge, instance);
                    if (totalDemand > instance.getCapacity())
                        continue;

                    bestSaving = saving;
                    bestMerge = merge;
                }
            }
            if (bestMerge == null)
                break;
            removeContainedRoutes(routes, bestMerge);
            routes.add(bestMerge);
        }

        return new VRPSolution(routes);
    }

    /**
     * Initialize the routes for the savings heuristic.
     */
    private static List<List<Integer>> initializeRoutes(VRPInstance instance) {
        List<List<Integer>> routes = new ArrayList<>();
        for (VRPNode node : instance.getNodes().values()) {
            if (node.getID() == 1)
                continue;
            routes.add(List.of(node.getID()));
        }
        return routes;
    }

    /**
     * Calculate the savings for the savings heuristic.
     * 
     * @param instance
     * @return a 2d double array of savings
     */
    private static double[][] calculateSavings(VRPInstance instance) {
        double[][] savings = new double[instance.getNodes().size() + 1][instance.getNodes().size() + 1];
        for (int i = 2; i < instance.getNodes().size(); i++) {
            for (int j = i + 1; j < instance.getNodes().size() + 1; j++) {
                VRPNode node1 = instance.getNodes().get(i);
                VRPNode node2 = instance.getNodes().get(j);

                double distanceToDepot = calculateEuclideanDistance(node1, instance.getDepot());
                double distanceFromDepot = calculateEuclideanDistance(instance.getDepot(), node2);
                double distanceBetweenNodes = calculateEuclideanDistance(node1, node2);

                savings[i][j] = distanceToDepot + distanceFromDepot - distanceBetweenNodes;
                savings[j][i] = savings[i][j];
            }
        }
        return savings;
    }

    /**
     * Merge two routes for the savings heuristic.
     * 
     * @param route1
     * @param route2
     * @param instance
     * @return the merged route
     */
    private static List<Integer> mergeRoutes(List<Integer> route1, List<Integer> route2, VRPInstance instance) {
        List<Integer> mergedRoute = new ArrayList<>(route1);
        mergedRoute.addAll(route2);
        return mergedRoute;
    }

    /**
     * Calculate the total demand of a route for the savings heuristic.
     * 
     * @param route
     * @param instance
     * @return the total demand of the route
     */
    private static double calculateTotalDemand(List<Integer> route, VRPInstance instance) {
        double totalDemand = 0;
        for (int nodeID : route) {
            totalDemand += instance.getNodes().get(nodeID).getDemand();
        }
        return totalDemand;
    }

    /**
     * Remove routes that are contained in the merged route for the savings
     * heuristic.
     * 
     * @param routes
     * @param mergedRoute
     */
    private static void removeContainedRoutes(List<List<Integer>> routes, List<Integer> mergedRoute) {
        for (int i = routes.size() - 1; i >= 0; i--) {
            if (mergedRoute.containsAll(routes.get(i))) {
                routes.remove(i);
            }
        }
    }
}